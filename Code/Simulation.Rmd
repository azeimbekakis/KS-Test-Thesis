---
title: "R Notebook"
output: html_notebook
---

```{r}
# Load packages
library(xtable)
library(dgof)
library(tidyverse)
```

```{r}
# Testing a simple random normal distribution
test_normal <- function(n_tests, n_samples) {
  
  p_values <- c()
  for(i in 1:n_tests) {
    
    # Generate random data, perform a KS-test, and store the p-value
    data <- rnorm(n_samples)
    p_values[i] <- ks.test(data, "pnorm")$p.value
  }
  
  samples_str <- paste("Samples:", n_samples)
  tests_str <- paste("Replicate tests:", n_tests)
  
  # Create a master data_frame for p-values
  tests <- c(rep(tests_str, n_tests))
  samples <- c(rep(samples_str, n_tests))
  results <- data_frame(p_values, tests, samples)
  
  return(results)
}

# Create the histograms displaying p-values from each test
test1 <- test_normal(10000, 10)
test2 <- test_normal(10000, 100)
test3 <- test_normal(10000, 1000)
test4 <- test_normal(10, 10000)
test5 <- test_normal(100, 10000)
test6 <- test_normal(1000, 10000)
results <- rbind(test1, test2, test3, test4, test5, test6)

# Generate histograms plot
hist_normal <- ggplot(results, aes(x = p_values)) + geom_histogram(color="gray", fill="white", bins = 20, size = 1) + theme(text=element_text(size=14)) + scale_x_continuous(name = "p-value", breaks=c(0, 1)) + facet_wrap(.~tests+samples, scales = "free_y")
```

```{r}
# Test to show that rounding changes the power of the test
test_rounded <- function(n_tests, n_samples, digits) {
  
  p_values <- c()
  for(i in 1:n_tests) {
    
    # Generate random rounded data, perform a KS-test, and store the p-value
    data <- round(rnorm(n_samples), digits)
    p_values[i] <- ks.test(data, "pnorm")$p.value
  }
  
  return(p_values)
}

# Create the histograms displaying p-values from each test
hist1 <- suppressWarnings(test_rounded(10000, 100, 4))
hist2 <- suppressWarnings(test_rounded(10000, 100, 3))
hist3 <- suppressWarnings(test_rounded(10000, 100, 2))
hist4 <- suppressWarnings(test_rounded(10000, 100, 1))

# Create a master data_frame with all the results
histogram <- c(rep(".0001", 10000), rep(".001", 10000), rep(".01", 10000), rep(".1", 10000))
p_values <- c(hist1, hist2, hist3, hist4)
results <- data_frame(p_values, histogram)

# Generate histograms plot
hist_rounded <- ggplot(results, aes(x = p_values)) + geom_histogram(color="gray", fill="white", boundary = 0, binwidth = 1/20, size = 1) + theme(text=element_text(size=14)) + scale_x_continuous(name = "p-value") + facet_wrap(.~histogram, scales = "free_y")
```

```{r}
# Test to show that autocorrelation changes the power of the test
test_correlation <- function(n_tests, ars) {
  
  # Create a master data_frame for p-values
  columns <- c("p_value", "ar")
  ar_results <- data.frame(matrix(ncol = 2, nrow = 0))
  colnames(ar_results) <- columns
  
  # For AR coefficients from -0.5 to 0.5
  for(i in 1:length(ars)) {
    
    for(j in 1:n_tests) {
      
      # Generate random correlated data, perform a KS-test, and store the p-value
      data <- arima.sim(model = list(ar = ars[i]), rand.gen = rnorm, sd = sqrt(1-ars[i]^2), n = 100)
      ar_results <- add_row(ar_results, p_value = ks.test(data, "pnorm")$p.value, ar = ars[i])
    }
  }
  
  return(ar_results)
}

 # Set AR coefficients and generate results
ars <- seq(-0.5, 0.5, by = 0.1)
ar_results <- suppressWarnings(test_correlation(1000, ars))

# Generate histograms plot
hist_correlation <- ggplot(ar_results, aes(x = p_value)) + geom_histogram(color="gray", fill="white", boundary = 0, binwidth = 1/20, size = 1) + theme(text=element_text(size=14)) + scale_x_continuous(name = "p-value", breaks=c(0, 1)) + facet_wrap(.~ar, scales = "free_y", ncol = 3)
```

```{r}
# Test the xtable package
test_table <- function(n_tests, n_samples) {
  results <- numeric(n_tests)
  for(i in 1:n_tests) {
    data <- rnorm(n_samples)
    results[i] <- ks.test(data, "pnorm")$p.value
  }
  power_level <- 1 - sum(results < 0.05) / n_tests
  return(power_level)
}
Tests_Samples <- c("10000, 10", "10000, 100", "10000, 1000", "10, 10000", "100, 10000", "1000, 10000")
Power_Level <- c(0, 0, 0, 0, 0, 0)
tab <- data.frame(Tests_Samples, Power_Level)
tab[1, "Power_Level"] <- test_table(10000, 10)
tab[2, "Power_Level"] <- test_table(10000, 100)
tab[3, "Power_Level"] <- test_table(10000, 1000)
tab[4, "Power_Level"] <- test_table(10, 10000)
tab[5, "Power_Level"] <- test_table(100, 10000)
tab[6, "Power_Level"] <- test_table(1000, 10000)
tab <- xtable(tab)
tab
```

```{r}
# Test the dgof package as a solution to rounded data with 30 or under samples
test_dgof <- function(n_tests, n_samples, digits, B = 100) {

  results1 <- c()
  results2 <- c()
  results3 <- c()

  # Create the rounded normal step function
  left <- -4-0.1^digits
  y <- pnorm(seq(left, 4, by = 0.1^digits))
  sfun  <- stepfun(seq(-4, 4, by = 0.1^digits), y)
  
  for (i in 1:n_tests) {
    
    if (i%%100 == 0) {
      cat(i, " ")
    }
    
    # Generate random rounded data, perform 3 KS-tests, and store the p-values
    # 1. Using the rounded normal step function
    # 2. Using the naive continuous standard normal function
    data <- round(rnorm(n_samples), digits)
    results1[i] <- ks.test(data, sfun)$p.value
    results2[i] <- ks.test(data, "pnorm")$p.value
  }
  
  # Create a master data_frame for p-values
  test <- c(rep("dgof", n_tests), rep("Naive", n_tests))
  digits <- c(rep(.1^digits, 2*n_tests))
  p_values <- c(results1, results2)
  results <- data_frame(p_values, test, digits)
  
  return(results)
}

# Create the histograms displaying p-values from each test
test1 <- suppressWarnings(test_dgof(10000, 100, 3))
test2 <- suppressWarnings(test_dgof(10000, 100, 2))
test3 <- suppressWarnings(test_dgof(10000, 100, 1))
results <- rbind(test1, test2, test3)

# Generate histograms plot
hist_dgof <- ggplot(results, aes(x = p_values)) + geom_histogram(color="gray", fill="white", boundary = 0, binwidth = 1/20, size = 1) + theme(text=element_text(size=14)) + scale_x_continuous(name = "p-value", breaks=c(0, 1)) + facet_wrap(.~test+digits, ncol = 3, scales = "free_y")
hist_dgof
```

```{r}
# Test the dgof package's simulate p-values as a solution to rounded data with over 30 samples
test_dgofsimulate <- function(n_tests, n_samples, digits, B = 100) {
  
  # Results lists
  results1 <- c()
  results2 <- c()
  
  # Create the rounded normal step function
  left <- -4-0.1^digits
  y <- pnorm(seq(left, 4, by = 0.1^digits))
  sfun  <- stepfun(seq(-4, 4, by = 0.1^digits), y)
  
  for (i in 1:n_tests) {
    
    # Generate random rounded data, perform 2 KS-tests, and store the p-values
    # 1. Using the rounded normal step function
    # 2. Using the rounded normal step function with simulated p-values
    test <- round(rnorm(n_samples), digits)
    results1[i] <- ks.test(test, sfun)$p.value
    results2[i] <- ks.test(test, sfun, simulate.p.value = TRUE, B = B)$p.value
  }
  
  # Create a master data_frame for p-values
  test <- c(rep("dgof", n_tests), rep("Simulated", n_tests))
  digits <- c(rep(.1^digits, 2*n_tests))
  p_values <- c(results1, results2)
  results <- data_frame(p_values, test, digits)
  
  return(results)
}

# Create the histograms displaying p-values from each test
test1 <- suppressWarnings(test_dgofsimulate(1000, 100, 1, 100))
test2 <- suppressWarnings(test_dgofsimulate(1000, 100, 2, 100))
results <- rbind(test1, test2)

# Generate histograms plot
hist_dgofsim <- ggplot(results, aes(x = p_values)) + geom_histogram(color="gray", fill="white", boundary = 0, binwidth = 1/20, size = 1) + theme(text=element_text(size=14)) + scale_x_continuous(name = "p-value", breaks=c(0, 1)) + facet_wrap(.~test+digits, scales = "free_y")
```

```{r}
# Split sample size into blocks, apply bootstrap onto blocks. Use that as x.b. Fit, stat.b
# Test parametric bootstrap as a solution to fitting parameters
test_parametric <- function(x, B = 1000) {
  
  # Summarize parameters
  mu <- mean(x)
  sigma <- sd(x)
  
  # Store KS statistic from using fitted parameters
  stat <- ks.test(x, "pnorm", mu, sigma)$statistic
  
  # Parametric bootstrap to approximate the null distribution
  n <- length(x)
  stat.b <- double(B)
  for (i in 1:B) {
    x.b <- rnorm(n, mu, sigma)
    mu.b <- mean(x.b)
    sigma.b <- sd(x.b)
    stat.b[i] <- ks.test(x.b, "pnorm", mu.b, sigma.b)$statistic
  }
  p.value <- (sum(stat.b >= stat) + 0.5) / (B + 1)
  
  list(statistics = stat, p.value = p.value, 
       estimate = c(mean = mu, sd = sigma),
       stat.sim = stat.b)
}

# Naive KS-test to show consequence of fitted parameters
test_naive <- function(x) {
  p.value <- ks.test(x, "pnorm", mean = mean(x), sd = sd(x))$p.value
  list(p.value = p.value)
}

# Generate results
pvals_parametric <- replicate(1000, test_parametric(rnorm(100), B = 1000)$p.value)
pvals_naive <- replicate(1000, test_naive(rnorm(100))$p.value)

# Create a master data_frame with all the results
histogram <- c(rep("Parametric", 1000), rep("Naive", 1000))
p_values <- c(pvals_parametric, pvals_naive)
results <- data_frame(p_values, histogram)

# Generate histograms plot
hist_parametric <- ggplot(results, aes(x = p_values)) + geom_histogram(color="gray", fill="white", boundary = 0, binwidth = 1/20, size = 1) + theme(text=element_text(size=14)) + scale_x_continuous(name = "p-value", breaks=c(0, 1)) + facet_wrap(.~histogram, scales = "free_y")

# Run KS-tests to check for uniform distribution
ks.test(pvals_parametric, "punif")
ks.test(pvals_naive, "punif")
```

```{r}
ggsave(filename="hist_normal.pdf", plot=hist_normal, path = "/Users/anthony/KS-Test-Thesis/Manuscript")
ggsave(filename="hist_rounded.pdf", plot=hist_rounded, path = "/Users/anthony//KS-Test-Thesis/Manuscript")
ggsave(filename="hist_correlation.pdf", plot=hist_correlation, path = "/Users/anthony/KS-Test-Thesis/Manuscript")
ggsave(filename="hist_dgof.pdf", plot=hist_dgof, path = "/Users/anthony/KS-Test-Thesis/Manuscript")
ggsave(filename="hist_dgofsim.pdf", plot=hist_dgofsim, path = "/Users/anthony/KS-Test-Thesis/Manuscript")
ggsave(filename="hist_parametric.pdf", plot=hist_parametric, path = "/Users/anthony/KS-Test-Thesis/Manuscript")
```
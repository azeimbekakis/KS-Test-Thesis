---
title: "R Notebook"
output: html_notebook
---

```{r}
# Load packages
library(xtable)
library(dgof)
library(tidyverse)
library(KSgeneral)
library(copula)
```

```{r hist_parametric}
# Test parametric bootstrap as a solution to fitting parameters
test_parametric <- function(x, B = 1000) {
  
  # Summarize parameters
  mu <- mean(x)
  sigma <- sd(x)
  
  # Store KS statistic from using fitted parameters
  stat <- ks.test(x, "pnorm", mu, sigma)$statistic
  
  # Parametric bootstrap to approximate the null distribution
  n <- length(x)
  stat.b <- double(B)
  for (i in 1:B) {
    x.b <- rnorm(n, mu, sigma)
    mu.b <- mean(x.b)
    sigma.b <- sd(x.b)
    stat.b[i] <- ks.test(x.b, "pnorm", mu.b, sigma.b)$statistic
  }
  p.value <- (sum(stat.b >= stat) + 0.5) / (B + 1)

  counter <<- counter + 1
  cat(counter, "")
  list(p.value = p.value)
}

test_babu <- function(x, B = 1000) {
  p.value <- ks.np.babu(x, B = 1000)$p.value
  counter <<- counter + 1
  cat(counter, "")
  list(p.value = p.value)
}

# Naive KS-test to show consequence of fitted parameters
test_naive <- function(x) {
  p.value <- ks.test(x, "pnorm", mean = mean(x), sd = sd(x))$p.value
  list(p.value = p.value)
}

# Generate results
n_tests = 100
n = 100
counter <- 0
pvals_parametric <- replicate(n_tests, test_parametric(rnorm(n), B = 1000)$p.value)
counter <- 0
pvals_babu <- replicate(n_tests, test_babu(rnorm(n), B = 1000)$p.value)
pvals_naive <- replicate(n_tests, test_naive(rnorm(n))$p.value)

# Create a master data_frame with all the results
histogram <- c(rep("Parametric", n_tests), rep("Babu", n_tests), rep("Naive", n_tests))
p_values <- c(pvals_parametric, pvals_babu, pvals_naive)
results <- data_frame(p_values, histogram)

# Generate histograms plot
hist_fitted <- ggplot(results) + 
                   geom_histogram(aes(x = p_values, fill = histogram), boundary = 0, binwidth = 1/20) + 
                   scale_x_continuous(name = "p-value", breaks=c(0, 1)) + 
                   theme(legend.position = "none") +
                   facet_wrap(~histogram, scales = "free_y")

# Save the histogram figure
ggsave(filename = "hist_fitted.pdf", plot = hist_fitted, path = "../Manuscript", height = 2.1, width = 6)
```

```{r hist_rounded}
# Test to show that rounding changes the power of the test
test_rounded <- function(n_tests, n_samples, digits) {
  
  p_values <- double(n_tests)
  
  for(i in 1:n_tests) {
    
    # Generate random rounded data, perform a KS-test, and store the p-value
    data <- round(rnorm(n_samples), digits)
    p_values[i] <- ks.test(data, "pnorm")$p.value
  }
  
  return(p_values)
}

# Create the histograms displaying p-values from each test
n_tests <- 1000
n <- 100
hist1 <- suppressWarnings(test_rounded(n_tests, n, 2))
hist2 <- suppressWarnings(test_rounded(n_tests, n, 1))

# Create a master data_frame with all the results
histogram <- c(rep(".01", n_tests), rep(".1", n_tests))
p_values <- c(hist1, hist2)
results <- data_frame(p_values, histogram)

# Generate histograms plot
hist_rounded <- ggplot(results) + 
                geom_histogram(aes(x = p_values, fill = histogram), binwidth = 1/20, boundary = 0) + 
                facet_grid(~histogram) +
                theme(legend.position = "none") +
                scale_x_continuous(name = "p-value", breaks = seq(0, 1))

# Save the histogram figure
ggsave(filename = "hist_rounded.pdf", plot = hist_rounded, path = "../Manuscript", height = 2.1, width = 6)

qqplot(hist1, runif(100), xlab = "Rounded", ylab = "Uniform", main = "Testing qqplot")
abline(0, 1)
p <- ggplot(results, aes(sample = p_values))
p + stat_qq(distribution = stats::qunif) + geom_abline(intercept = 0, slope = 1) + xlim(0, 1) + ylim(0, 1)
```

```{r hist_general}
# Test the KSgeneral package as a solution to rounded data
test_general <- function(n_tests, n_samples, digits, B) {

  results1 <- double(n_tests)
  results2 <- double(n_tests)
  results3 <- double(n_tests)
  results4 <- double(n_tests)

  # Create the rounded normal step function
  left <- -4-0.1^digits
  y <- pnorm(seq(left, 4, by = 0.1^digits))
  sfun  <- stepfun(seq(-4, 4, by = 0.1^digits), y)
  
  for (i in 1:n_tests) {
    cat(i, "")
    # Generate random rounded data, perform 3 KS-tests, and store the p-values
    # 1. Using the rounded normal step function
    # 2. Using the naive continuous standard normal function
    data <- round(rnorm(n_samples), digits)
    results1[i] <- KSgeneral::disc_ks_test(data, sfun, exact = TRUE)$p.value
    results2[i] <- dgof::ks.test(data, sfun)$p.value
    results3[i] <- ks.test(data, sfun, simulate.p.value = TRUE, B = B)$p.value
    results4[i] <- ks.test(data, "pnorm")$p.value
  }
  
  # Create a master data_frame for p-values
  test <- c(rep("KSgeneral", n_tests), rep("dgof", n_tests), rep("dgofsim", n_tests), rep("Naive", n_tests))
  digits <- c(rep(.1^digits, 4*n_tests))
  p_values <- c(results1, results2, results3, results4)
  results <- data_frame(p_values, test, digits)
  
  return(results)
}

ptm <- proc.time()

n_tests = 100
n = 100
B = 1000

# Create the histograms displaying p-values from each test
test1 <- suppressWarnings(test_general(n_tests, n, digits = 2, B = B))
test2 <- suppressWarnings(test_general(n_tests, n, digits = 1, B = B))
results <- rbind(test1, test2)

# Generate histograms plot
hist_general <- ggplot(results) + 
                geom_histogram(aes(x = p_values, fill = test), boundary = 0, binwidth = 1/20) + 
                scale_x_continuous(name = "p-value", breaks=c(0, 1)) + 
                facet_grid(test~digits) +
                theme(legend.position = "none")

# Save the histogram figure
ggsave(filename = "hist_general.pdf", plot = hist_general, path = "../Manuscript", height = 4.2, width = 6)

proc.time() - ptm

qqplot(test1$p_values[1:100], runif(100), xlab = "KSGeneral", ylab = "Uniform", main = "Testing qqplot")
abline(0, 1)
# could try qqplot for unit interval
# is qqplot close to 45 degree line, otherwise no
```

```{r hist_correlation}
# Test to show that autocorrelation changes the power of the test
test_correlation <- function(n_tests, ars) {
  
  # Create a master data_frame for p-values
  columns <- c("p_value", "ar")
  ar_results <- data.frame(matrix(ncol = 2, nrow = 0))
  colnames(ar_results) <- columns
  
  # For AR coefficients from -0.5 to 0.5
  for(i in 1:length(ars)) {
    
    for(j in 1:n_tests) {
      
      # Generate random correlated data, perform a KS-test, and store the p-value
      data <- arima.sim(model = list(ar = ars[i]), rand.gen = rnorm, sd = sqrt(1-ars[i]^2), n = 100)
      ar_results <- add_row(ar_results, p_value = ks.test(data, "pnorm")$p.value, ar = round(ars[i], 1))
    }
  }
  
  return(ar_results)
}

 # Set AR coefficients and generate results
ars <- seq(-0.3, 0.3, by = 0.1)
ar_results <- test_correlation(1000, ars)

# Generate histograms plot
hist_correlation <- ggplot(ar_results) + 
                    geom_histogram(aes(x = p_value, fill = ar), boundary = 0, binwidth = 1/20) + 
                    facet_grid(~ar) +
                    theme(legend.position = "none") +
                    scale_x_continuous(name = "p-value", breaks=c(0, 1))

# Save the histogram figure
ggsave(filename = "hist_correlation.pdf", plot = hist_correlation, path = "../Manuscript", height = 2.1, width = 6)
```

```{r babu}
ecdf.leftcont <- function (x) {
    x <- sort(x)
    n <- length(x)
    if (n < 1) 
        stop("'x' must have 1 or more non-missing values")
    vals <- unique(x)
    ## making it left continuous!
    rval <- approxfun(vals, cumsum(tabulate(match(x, vals)))/n - 1/n, 
        method = "constant", yleft = 0, yright = 1, f = 1, ties = "ordered")
    class(rval) <- c("ecdf", "stepfun", class(rval))
    assign("nobs", n, envir = environment(rval))
    attr(rval, "call") <- sys.call()
    rval
}

ks.np.babu <- function(x, B = 1000) {
    ## for normal distribution only
    n <- length(x)
    Fn <- ecdf(x)
    Gn <- ecdf.leftcont(x)
    mu <- mean(x); ss <- sd(x)
    Ftheta <- pnorm(x, mu, ss)
    Bn1 <- Fn(x) - Ftheta
    Bn2 <- Gn(x) - Ftheta
    d1 <- abs(Bn1)
    d2 <- abs(Bn2)
    stat <- max(d1, d2)
    stat.b <- double(B)
    for (i in 1:B) {
        x.b <- sample(x, size = n, replace = TRUE)
        Fn.b <- ecdf(x.b)
        Gn.b <- ecdf.leftcont(x.b)
        mu.b <- mean(x.b); ss.b <- sd(x.b)
        ## evaluate at x (not x.b)
        Ftheta.b <- pnorm(x, mu.b, ss.b)
        d1.b <- abs(Fn.b(x) - Ftheta.b - Bn1)
        d2.b <- abs(Gn.b(x) - Ftheta.b - Bn2)
        stat.b[i] <- max(d1.b, d2.b)
    }
    p.value <-  (sum(stat.b >= stat) + 0.5) / (B + 1)
    list(p.value = p.value,
         statistic = stat, stat.b = stat.b)
}
```

```{r}
test_copula <- function(x, dist, B = 100) {
    ## example assuming normal distribution; normal copula
    ## get observed stat
    n <- length(x)
    mu <- mean(x)
    sigma <- sd(x)
    stat  <- ks.test(x, dist, mean = mu, sd = sigma)$statistic
    ## get lag-1 sample auto-spearman rho
    rho  <-  cor(x[-1], x[-n], method = "spearman")
    r <- iRho(normalCopula(), rho)
    np <- normalCopula(r)
    ## parametric bootstrap to get an empirical distribution of stat
    stat.b <- double(n)
    ## set up containers
    for (i in 1:B) {
        ## get one bootstrap sample
        ## 1. the marginal distribution is the fitted dist
        ## 2. there is temporal dependence
        u <- runif(n)
        for (j in 2:n) {
            ## could test other copulas later
            u[j]  <- cCopula(c(u[j-1], u[j]), np, indices = 2, inverse = TRUE)
        }
        ## get bootstrap sample
        x.b <- qnorm(u, mean = mu, sd = sigma)
        ## fit it
        mu.b <- mean(x.b)
        sigma.b <- sd(x.b)
        stat.b[i] <- ks.test(x.b, dist, mean = mu.b, sd = sigma.b)$statistic
    }
    
    p.value <- (sum(stat.b >= stat) + 0.5) / (B + 1)
    
    counter <<- counter + 1
    cat(counter)
    
    return(p.value)
    # return empirical p-value    
}

# Naive KS-test
test_naive_copula <- function(x) {
  p.value <- ks.test(x, "pnorm")$p.value
  list(p.value = p.value)
}

# Generate results
n <- 100
ar = 0.5
counter <- 0
nrep <- 1000
pvals_copula <- replicate(nrep, test_copula(arima.sim(list(ar = ar), rand.gen=rnorm, sd = sqrt(1 - ar^2), n = n), "pnorm"))
pvals_naive <- replicate(nrep, test_naive_copula(arima.sim(list(ar = ar), rand.gen=rnorm, sd = sqrt(1 - ar^2), n = n))$p.value)

# Create a master data_frame with all the results
histogram <- c(rep("Copula", nrep), rep("Naive", nrep))
p_values <- c(pvals_copula, pvals_naive)
results <- data_frame(p_values, histogram)

# Generate histograms plot
hist_copula <- ggplot(results) + 
                   geom_histogram(aes(x = p_values, fill = histogram), boundary = 0, binwidth = 1/20) + 
                   scale_x_continuous(name = "p-value", breaks=c(0, 1)) + 
                   theme(legend.position = "none") +
                   facet_wrap(~histogram, scales = "free_y")
hist_copula

# Save the histogram figure
ggsave(filename = "hist_copula.pdf", plot = hist_copula, path = "../Manuscript", height = 2.1, width = 6)
```
---
title: "R Notebook"
output: html_notebook
---

```{r}
# Load packages
library(xtable)
library(dgof)
library(tidyverse)
library(KSgeneral)
library(copula)
library(evd)
source('tspb.R')
```

```{r hist_parametric}
# Test parametric bootstrap as a solution to fitting parameters
test_parametric <- function(x, B = 1000) {
  
  # Summarize parameters
  mu <- mean(x)
  sigma <- sd(x)
  
  # Store KS statistic from using fitted parameters
  stat <- ks.test(x, "pnorm", mu, sigma)$statistic
  
  # Parametric bootstrap to approximate the null distribution
  n <- length(x)
  stat.b <- double(B)
  for (i in 1:B) {
    x.b <- rnorm(n, mu, sigma)
    mu.b <- mean(x.b)
    sigma.b <- sd(x.b)
    stat.b[i] <- ks.test(x.b, "pnorm", mu.b, sigma.b)$statistic
  }
  
  # Return empirical p-value
  p.value <- (sum(stat.b >= stat) + 0.5) / (B + 1)

  counter <<- counter + 1
  cat(counter, "")
  list(p.value = p.value)
}

# Test non-parametric bootstrap as a solution to fitted parameters
test_babu <- function(x, B = 1000) {
  p.value <- ks.np.babu(x, B = 1000)$p.value
  counter <<- counter + 1
  cat(counter, "")
  list(p.value = p.value)
}

# Naive KS-test to show consequence of fitted parameters
test_naive <- function(x) {
  p.value <- ks.test(x, "pnorm", mean = mean(x), sd = sd(x))$p.value
  list(p.value = p.value)
}

# Generate results
n_tests = 100
n = 100
counter <- 0
pvals_parametric <- replicate(n_tests, test_parametric(rnorm(n), B = 1000)$p.value)
counter <- 0
pvals_babu <- replicate(n_tests, test_babu(rnorm(n), B = 1000)$p.value)
pvals_naive <- replicate(n_tests, test_naive(rnorm(n))$p.value)

# Create a master data_frame with all the results
histogram <- c(rep("Parametric", n_tests), rep("Babu", n_tests), rep("Naive", n_tests))
p_values <- c(pvals_parametric, pvals_babu, pvals_naive)
results <- data_frame(p_values, histogram)

# Generate histograms plot
hist_fitted <- ggplot(results) + 
                   geom_histogram(aes(x = p_values, fill = histogram), boundary = 0, binwidth = 1/20) + 
                   scale_x_continuous(name = "p-value", breaks=c(0, 1)) + 
                   theme(legend.position = "none") +
                   facet_wrap(~histogram, scales = "free_y")

# Save the histogram figure
ggsave(filename = "hist_fitted.pdf", plot = hist_fitted, path = "../Manuscript", height = 2.1, width = 6)
```

```{r hist_rounded}
# Test to show that rounding changes the power of the test
test_rounded <- function(n_tests, n_samples, digits) {
  
  p_values <- double(n_tests)
  
  for(i in 1:n_tests) {
    
    # Generate random rounded data, perform a KS-test, and store the p-value
    data <- round(rnorm(n_samples), digits)
    p_values[i] <- ks.test(data, "pnorm")$p.value
  }
  
  return(p_values)
}

# Create the histograms displaying p-values from each test
n_tests <- 1000
n <- 100
hist1 <- suppressWarnings(test_rounded(n_tests, n, 2))
hist2 <- suppressWarnings(test_rounded(n_tests, n, 1))

# Create a master data_frame with all the results
histogram <- c(rep(".01", n_tests), rep(".1", n_tests))
p_values <- c(hist1, hist2)
results <- data_frame(p_values, histogram)

# Generate histograms plot
hist_rounded <- ggplot(results) + 
                geom_histogram(aes(x = p_values, fill = histogram), binwidth = 1/20, boundary = 0) + 
                facet_grid(~histogram) +
                theme(legend.position = "none") +
                scale_x_continuous(name = "p-value", breaks = seq(0, 1))

# Save the histogram figure
ggsave(filename = "hist_rounded.pdf", plot = hist_rounded, path = "../Manuscript", height = 2.1, width = 6)

qqplot(hist2, runif(100), xlab = "Rounded", ylab = "Uniform", main = "Testing qqplot")
abline(0, 1)
p <- ggplot(results, aes(sample = p_values))
p + stat_qq(distribution = stats::qunif) + geom_abline(intercept = 0, slope = 1) + xlim(0, 1) + ylim(0, 1)
```

```{r hist_general}
# Test the KSgeneral package as a solution to rounded data
test_general <- function(n_tests, n_samples, digits, B) {

  results1 <- double(n_tests)
  results2 <- double(n_tests)
  results3 <- double(n_tests)
  results4 <- double(n_tests)

  # Create the rounded normal step function
  left <- -4-0.1^digits
  y <- pnorm(seq(left, 4, by = 0.1^digits))
  sfun  <- stepfun(seq(-4, 4, by = 0.1^digits), y)
  
  for (i in 1:n_tests) {
    cat(i, "")
    # Generate random rounded data, perform 3 KS-tests, and store the p-values
    # 1. Using the rounded normal step function
    # 2. Using the naive continuous standard normal function
    data <- round(rnorm(n_samples), digits)
    results1[i] <- KSgeneral::disc_ks_test(data, sfun, exact = TRUE)$p.value
    results2[i] <- dgof::ks.test(data, sfun, exact = TRUE)$p.value
    results3[i] <- ks.test(data, sfun, simulate.p.value = TRUE, B = B)$p.value
    results4[i] <- ks.test(data, "pnorm")$p.value
  }
  
  # Create a master data_frame for p-values
  test <- c(rep("KSgeneral", n_tests), rep("dgof", n_tests), rep("dgofsim", n_tests), rep("Naive", n_tests))
  digits <- c(rep(.1^digits, 4*n_tests))
  p_values <- c(results1, results2, results3, results4)
  results <- data_frame(p_values, test, digits)
  
  return(results)
}

ptm <- proc.time()

n_tests = 100
n = 30
B = 1000

# Create the histograms displaying p-values from each test
test1 <- suppressWarnings(test_general(n_tests, n, digits = 2, B = B))
test2 <- suppressWarnings(test_general(n_tests, n, digits = 1, B = B))
results <- rbind(test1, test2)

# Generate histograms plot
hist_general <- ggplot(results) + 
                geom_histogram(aes(x = p_values, fill = test), boundary = 0, binwidth = 1/20) + 
                scale_x_continuous(name = "p-value", breaks=c(0, 1)) + 
                facet_grid(test~digits) +
                theme(legend.position = "none")

# Save the histogram figure
ggsave(filename = "hist_general.pdf", plot = hist_general, path = "../Manuscript", height = 4.2, width = 6)

proc.time() - ptm

qqplot(test1$p_values[1:100], runif(100), xlab = "KSGeneral", ylab = "Uniform", main = "Testing qqplot")
abline(0, 1)
# could try qqplot for unit interval
# is qqplot close to 45 degree line, otherwise no
```

```{r hist_correlation}
# Test to show that autocorrelation changes the power of the test
test_correlation <- function(n_tests, ars) {
  
  # Create a master data_frame for p-values
  columns <- c("p_value", "ar")
  ar_results <- data.frame(matrix(ncol = 2, nrow = 0))
  colnames(ar_results) <- columns
  
  # For AR coefficients from -0.5 to 0.5
  for(i in 1:length(ars)) {
    
    for(j in 1:n_tests) {
      
      # Generate random correlated data, perform a KS-test, and store the p-value
      data <- arima.sim(model = list(ar = ars[i]), rand.gen = rnorm, sd = sqrt(1-ars[i]^2), n = 100)
      ar_results <- add_row(ar_results, p_value = ks.test(data, "pnorm")$p.value, ar = round(ars[i], 1))
    }
  }
  
  return(ar_results)
}

 # Set AR coefficients and generate results
ars <- seq(-0.3, 0.3, by = 0.1)
ar_results <- test_correlation(1000, ars)

# Generate histograms plot
hist_correlation <- ggplot(ar_results) + 
                    geom_histogram(aes(x = p_value, fill = ar), boundary = 0, binwidth = 1/20) + 
                    facet_grid(~ar) +
                    theme(legend.position = "none") +
                    scale_x_continuous(name = "p-value", breaks=c(0, 1))

# Save the histogram figure
ggsave(filename = "hist_correlation.pdf", plot = hist_correlation, path = "../Manuscript", height = 2.1, width = 6)
```

```{r babu}
ecdf.leftcont <- function (x) {
    x <- sort(x)
    n <- length(x)
    if (n < 1) 
        stop("'x' must have 1 or more non-missing values")
    vals <- unique(x)
    ## making it left continuous!
    rval <- approxfun(vals, cumsum(tabulate(match(x, vals)))/n - 1/n, 
        method = "constant", yleft = 0, yright = 1, f = 1, ties = "ordered")
    class(rval) <- c("ecdf", "stepfun", class(rval))
    assign("nobs", n, envir = environment(rval))
    attr(rval, "call") <- sys.call()
    rval
}

ks.np.babu <- function(x, B = 1000) {
    ## for normal distribution only
    n <- length(x)
    Fn <- ecdf(x)
    Gn <- ecdf.leftcont(x)
    mu <- mean(x); ss <- sd(x)
    Ftheta <- pnorm(x, mu, ss)
    Bn1 <- Fn(x) - Ftheta
    Bn2 <- Gn(x) - Ftheta
    d1 <- abs(Bn1)
    d2 <- abs(Bn2)
    stat <- max(d1, d2)
    stat.b <- double(B)
    for (i in 1:B) {
        x.b <- sample(x, size = n, replace = TRUE)
        Fn.b <- ecdf(x.b)
        Gn.b <- ecdf.leftcont(x.b)
        mu.b <- mean(x.b); ss.b <- sd(x.b)
        ## evaluate at x (not x.b)
        Ftheta.b <- pnorm(x, mu.b, ss.b)
        d1.b <- abs(Fn.b(x) - Ftheta.b - Bn1)
        d2.b <- abs(Gn.b(x) - Ftheta.b - Bn2)
        stat.b[i] <- max(d1.b, d2.b)
    }
    p.value <-  (sum(stat.b >= stat) + 0.5) / (B + 1)
    list(p.value = p.value,
         statistic = stat, stat.b = stat.b)
}
```

```{r}
test_copula <- function(x, dist, B) {

    # Get observed statistic
    n <- length(x)
    mu <- mean(x)
    sigma <- sd(x)
    stat  <- ks.test(x, dist, mean = mu, sd = sigma)$statistic
    
    # Get lag-1 sample auto-spearman rho
    rho  <-  cor(x[-1], x[-n], method = "spearman")
    r <- iRho(normalCopula(), rho)
    np <- normalCopula(r)
    
    # Perform parametric bootstrap to get an empirical distribution of stat
    stat.b <- double(n)
    
    for (i in 1:B) {
        # 1. The marginal distribution is the fitted dist
        # 2. There is temporal dependence
        u <- runif(n) 
        for (j in 2:n) {
            u[j]  <- cCopula(c(u[j-1], u[j]), np, indices = 2, inverse = TRUE)
        }
        
        # Transform bootstrap sample and fit the parameters
        x.b <- qnorm(u, mean = mu, sd = sigma)
        mu.b <- mean(x.b)
        sigma.b <- sd(x.b)
        
        # Gather bootstrap sample's test statistic
        stat.b[i] <- ks.test(x.b, dist, mean = mu.b, sd = sigma.b)$statistic
    }
    
    # Return empirical p-value
    p.value <- (sum(stat.b >= stat) + 0.5) / (B + 1)
    
    counter <<- counter + 1
    cat(counter, "")
    
    return(p.value)
}

# Super naive KS-test with fitted parameters
test_super_naive <- function(x) {
  p.value <- ks.test(x, "pnorm", mean = mean(x), sd = sd(x))$p.value
  list(p.value = p.value)
}

ptm <- proc.time()

# Generate results
n <- 100
ar <- 0.5
counter <- 0
nrep <- 1000
B <- 100
pvals_copula <- replicate(nrep, test_copula(arima.sim(list(ar = ar), rand.gen=rnorm, sd = sqrt(1 - ar^2), n = n), "pnorm", B = B))
counter <- 0
pvals_parametric <- replicate(nrep, test_parametric(arima.sim(list(ar = ar), rand.gen=rnorm, sd = sqrt(1 - ar^2), n = n))$p.value)
pvals_naive <- replicate(nrep, test_super_naive(arima.sim(list(ar = ar), rand.gen=rnorm, sd = sqrt(1 - ar^2), n = n))$p.value)

# Create a master data_frame with all the results
histogram <- c(rep("Copula", nrep), rep("Naive Parametric", nrep), rep("Super Naive", nrep))
p_values <- c(pvals_copula, pvals_parametric, pvals_naive)
results <- data_frame(p_values, histogram)

# Generate histograms plot
hist_copula <- ggplot(results) + 
                   geom_histogram(aes(x = p_values, fill = histogram), boundary = 0, binwidth = 1/20) + 
                   scale_x_continuous(name = "p-value", breaks=c(0, 1)) + 
                   theme(legend.position = "none") +
                   facet_wrap(~histogram, scales = "free_y")
hist_copula

print(proc.time() - ptm)

# Save the histogram figure
ggsave(filename = "hist_copula.pdf", plot = hist_copula, path = "../Manuscript", height = 2.1, width = 6)
```

```{r}
## Test AR(2) model
ptm <- proc.time()

# Set variables
n <- 100
counter <- 0
nrep <- 1000
B <- 100
b1 <- 0.5
b2 <- 0.3

# P-vals from using bootstrap with copulas
pvals_copula <- replicate(nrep, test_copula(arima.sim(list(order = c(2, 0, 0), 
                                                           ar = c(b1, b2)),
                                                      rand.gen=rnorm,
                                                      sd = sqrt(((1+b2)*(1-b2-b1)*(1-b2+b1))/(1-b2)),
                                                      n = n), 
                                            "pnorm", 
                                            B = B))
counter <- 0

# P-vals from using parametric bootstrap
pvals_parametric <- replicate(nrep, test_parametric(arima.sim(list(order = c(2, 0, 0), 
                                                                   ar = c(b1, b2)), 
                                                              rand.gen=rnorm, 
                                                              sd = sqrt(((1+b2)*(1-b2-b1)*(1-b2+b1))/(1-b2)), 
                                                              n = n))$p.value)

# P-vals from naively using fitted parameters
pvals_naive <- replicate(nrep, test_super_naive(arima.sim(list(order = c(2, 0, 0), 
                                                               ar = c(b1, b2)), 
                                                          rand.gen=rnorm, 
                                                          sd = sqrt(((1+b2)*(1-b2-b1)*(1-b2+b1))/(1-b2)), 
                                                          n = n))$p.value)

# Create a master data_frame with all the results
histogram <- c(rep("Copula", nrep), rep("Naive Parametric", nrep), rep("Super Naive", nrep))
p_values <- c(pvals_copula, pvals_parametric, pvals_naive)
results <- data_frame(p_values, histogram)

# Generate histograms plot
hist_copula_ar2 <- ggplot(results) + 
                   geom_histogram(aes(x = p_values, fill = histogram), boundary = 0, binwidth = 1/20) + 
                   scale_x_continuous(name = "p-value", breaks=c(0, 1)) + 
                   theme(legend.position = "none") +
                   facet_wrap(~histogram, scales = "free_y")

print(proc.time() - ptm)

hist_copula_ar2

# Save the histogram figure
ggsave(filename = "hist_copula_ar2.pdf", plot = hist_copula_ar2, path = "../Manuscript", height = 2.1, width = 6)
```

```{r}
## Test MA(1) model
ptm <- proc.time()

# Set variables
n <- 100
counter <- 0
nrep <- 1000
B <- 100
ma <- 0.5

# P-vals from using bootstrap with copulas
pvals_copula <- replicate(nrep, test_copula(arima.sim(list(ma = 0.5), rand.gen = rnorm, sd = sqrt(1/(1+ma^2)), n = n), "pnorm", B = B))
counter <- 0

# P-vals from using parametric bootstrap
pvals_parametric <- replicate(nrep, test_parametric(arima.sim(list(ma = 0.5), rand.gen = rnorm, sd = sqrt(1/(1+ma^2)), n = n))$p.value)

# P-vals from naively using fitted parameters
pvals_naive <- replicate(nrep, test_super_naive(arima.sim(list(ma = 0.5), rand.gen = rnorm, sd = sqrt(1/(1+ma^2)), n = n))$p.value)

# Create a master data_frame with all the results
histogram <- c(rep("Copula", nrep), rep("Naive Parametric", nrep), rep("Super Naive", nrep))
p_values <- c(pvals_copula, pvals_parametric, pvals_naive)
results <- data_frame(p_values, histogram)

# Generate histograms plot
hist_copula_ma1 <- ggplot(results) + 
                   geom_histogram(aes(x = p_values, fill = histogram), boundary = 0, binwidth = 1/20) + 
                   scale_x_continuous(name = "p-value", breaks=c(0, 1)) + 
                   theme(legend.position = "none") +
                   facet_wrap(~histogram, scales = "free_y")

print(proc.time() - ptm)

hist_copula_ma1

# Save the histogram figure
ggsave(filename = "hist_copula_ma1.pdf", plot = hist_copula_ma1, path = "../Manuscript", height = 2.1, width = 6)
```

```{r}
## Test ARMA(1,1) model
ptm <- proc.time()

# Set variables
n <- 100
counter <- 0
nrep <- 1000
B <- 100
ar <- 0.5
ma <- 0.3

# P-vals from using bootstrap with copulas
pvals_copula <- replicate(nrep, test_copula(arima.sim(list(ar = ar, 
                                                           ma = ma), 
                                                      rand.gen=rnorm, 
                                                      sd = sqrt((1-(ar^2))/(1+2*ar*ma+ma^2)), 
                                                      n = n),
                                            "pnorm", B = B))
counter <- 0

# P-vals from using parametric bootstrap
pvals_parametric <- replicate(nrep, test_parametric(arima.sim(list(ar = ar, 
                                                              ma = ma), 
                                                      rand.gen=rnorm, 
                                                      sd = sqrt((1-(ar^2))/(1+2*ar*ma+ma^2)), 
                                                      n = n))$p.value)

# P-vals from naively using fitted parameters
pvals_naive <- replicate(nrep, test_super_naive(arima.sim(list(ar = ar, 
                                                              ma = ma), 
                                                      rand.gen=rnorm, 
                                                      sd = sqrt((1-(ar^2))/(1+2*ar*ma+ma^2)), 
                                                      n = n))$p.value)

# Create a master data_frame with all the results
histogram <- c(rep("Copula", nrep), rep("Naive Parametric", nrep), rep("Super Naive", nrep))
p_values <- c(pvals_copula, pvals_parametric, pvals_naive)
results <- data_frame(p_values, histogram)

# Generate histograms plot
hist_copula_arma <- ggplot(results) + 
                   geom_histogram(aes(x = p_values, fill = histogram), boundary = 0, binwidth = 1/20) + 
                   scale_x_continuous(name = "p-value", breaks=c(0, 1)) + 
                   theme(legend.position = "none") +
                   facet_wrap(~histogram, scales = "free_y")

print(proc.time() - ptm)

hist_copula_arma

# Save the histogram figure
ggsave(filename = "hist_copula_arma.pdf", plot = hist_copula_arma, path = "../Manuscript", height = 2.1, width = 6)
```

```{r}
## wcopula: working copula assumed in constructing bootstrap sample
test_copula2 <- function(x, dist, B = 100, wcopula = normalCopula) {
    ## example assuming normal distribution; normal copula
    ## get observed stat
    n <- length(x)
    ## get fitted parameters; could check MASS::fitdistr for general solution
    ## the next two lines only work when dist is normal
    mu <- mean(x)
    sigma <- sd(x)
    stat  <- ks.test(x, dist, mean = mu, sd = sigma)$statistic
    ## get lag-1 sample auto-spearman rho
    rho  <-  cor(x[-1], x[-n], method = "spearman")
    r <- iRho(wcopula(), rho)
    wcop <- wcopula(r)
    ## parametric bootstrap to get an empirical distribution of stat
    stat.b <- double(n)
    ## set up containers
    for (i in 1:B) {
        ## get one bootstrap sample
        ## 1. the marginal distribution is the fitted dist
        ## 2. there is temporal dependence
        u <- runif(n)
        for (j in 2:n) {
            ## could test other copulas later
            u[j]  <- cCopula(c(u[j-1], u[j]), wcop, indices = 2, inverse = TRUE)
        }
        ## get bootstrap sample
        ## get fitted parameters for the bootstrap sample
        ## the next lines only work when dist is normal
        x.b <- qnorm(u, mean = mu, sd = sigma)
        mu.b <- mean(x.b)
        sigma.b <- sd(x.b)
        stat.b[i] <- ks.test(x.b, dist, mean = mu.b, sd = sigma.b)$statistic
    }
    ## return empirical p-value    
    p.value <- (sum(stat.b >= stat) + 0.5) / (B + 1)
    
    counter <<- counter + 1
    cat(counter, "")
    
    return(p.value)
}

## generating observations from a specified distribution with serial dependence
genData <- function(n, qdist, ..., copula, rho) {
    ## n: sample size
    ## qdist: quantile function of the desired marginal distribution
    ## copula: copula for serial distribution
    ## rho: spearman's rho
    theta <- iRho(copula(), rho)
    cop <- copula(theta)
    u <- runif(n)
    for (j in 2:n) {
        u[j] <- cCopula(c(u[j-1], u[j]), cop, indices = 2, inverse = TRUE)
    }
    qdist(u, ...)
}

# Naive KS-test
test_naive_copula <- function(x) {
  p.value <- ks.test(x, "pnorm")$p.value
  list(p.value = p.value)
}

ptm <- proc.time()

# Generate results
n <- 100
rho <- 0.5
counter <- 0
nrep <- 100
B <- 100
pvals_copula <- replicate(nrep, test_copula2(genData(n, qnorm, mean = 1, sd = 1, copula = claytonCopula, rho = rho), "pnorm", B = B))
pvals_naive <- replicate(nrep, test_naive_copula(genData(n, qnorm, mean = 1, sd = 1, copula = claytonCopula, rho = rho))$p.value)

# Create a master data_frame with all the results
histogram <- c(rep("Copula", nrep), rep("Naive", nrep))
p_values <- c(pvals_copula, pvals_naive)
results <- data_frame(p_values, histogram)

# Generate histograms plot
hist_copula2 <- ggplot(results) + 
                   geom_histogram(aes(x = p_values, fill = histogram), boundary = 0, binwidth = 1/20) + 
                   scale_x_continuous(name = "p-value", breaks=c(0, 1)) + 
                   theme(legend.position = "none") +
                   facet_wrap(~histogram, scales = "free_y")

print(proc.time() - ptm)

hist_copula2

# Save the histogram figure
#ggsave(filename = "hist_copula_c2.pdf", plot = hist_copula_c, path = "../Manuscript", height = 2.1, width = 6)
```

```{r}
# Testing bootstrap with copulas for gamma distribution
test_gamma <- function(x, dist, B = 100, wcopula = normalCopula) {

    # Get observed stat
    n <- length(x)
    m <- mean(x)
    v <- var(x)
    scale <- v/m
    shape <- m*m/v
    
    stat  <- ks.test(x, dist, shape = shape, scale = scale)$statistic

    # Get lag-1 sample auto-spearman rho
    rho  <-  cor(x[-1], x[-n], method = "spearman")
    r <- iRho(wcopula(), rho)
    wcop <- wcopula(r)
    
    # Parametric bootstrap to get an empirical distribution of stat
    stat.b <- double(n)
    
    for (i in 1:B) {
        # 1. The marginal distribution is the fitted dist
        # 2. There is temporal dependence
        u <- runif(n)
        for (j in 2:n) {
            u[j]  <- cCopula(c(u[j-1], u[j]), wcop, indices = 2, inverse = TRUE)
        }
        
        # Transform the bootstrap sample and fit the parameters
        x.b <- qgamma(u, shape = shape, scale = scale)
        
        m.b <- mean(x.b)
        v.b <- var(x.b)
        scale.b <- v.b/m.b
        shape.b <- m.b*m.b/v.b
        
        # Calculate new test statistic
        stat.b[i] <- ks.test(x.b, dist, shape = shape.b, scale = scale.b)$statistic
    }
    
    # Return empirical p-value    
    p.value <- (sum(stat.b >= stat) + 0.5) / (B + 1)
    
    counter <<- counter + 1
    cat(counter, "")
    
    return(p.value)
}

# Parametric bootstrap to solve fitted parameters for gamma distribution
test_parametric_gamma <- function(x, B = 1000) {
  
  # Summarize parameters
  m <- mean(x)
  v <- var(x)
  scale <- v/m
  shape <- m*m/v
  
  # Store KS statistic from using fitted parameters
  stat <- ks.test(x, "pgamma", shape = shape, scale = scale)$statistic
  
  # Parametric bootstrap to approximate the null distribution
  n <- length(x)
  stat.b <- double(B)
  for (i in 1:B) {
    x.b <- rgamma(n, shape = shape, scale = scale)
    
    m.b <- mean(x.b)
    v.b <- var(x.b)
    
    scale.b <- v.b/m.b
    shape.b <- m.b*m.b/v.b
    
    stat.b[i] <- ks.test(x.b, "pgamma", shape = shape.b, scale = scale.b)$statistic
  }
  
  # Return empirical p-value
  p.value <- (sum(stat.b >= stat) + 0.5) / (B + 1)

  counter <<- counter + 1
  cat(counter, "")
  list(p.value = p.value)
}

# Naive function that incorrectly uses fitted parameters for gamma distribution
test_super_naive_gamma <- function(x) {
  
  m <- mean(x)
  v <- var(x)
  scale <- v/m
  shape <- m*m/v
  
  p.value <- ks.test(x, "pgamma", shape = shape, scale = scale)$p.value
  list(p.value = p.value)
}

ptm <- proc.time()

# Set variables
n <- 100
rho <- 0.7
counter <- 0
nrep <- 1000
B <- 100

# P-vals from using bootstrap with copulas
pvals_copula <- replicate(nrep, test_gamma(genData(n, qgamma, shape = 3, scale = 1, copula = normalCopula, rho = rho), "pgamma", B = B))
counter <- 0

# P-vals from using parametric bootstrap
pvals_parametric <- replicate(nrep, test_parametric_gamma(genData(n, qgamma, shape = 3, scale = 1, copula = normalCopula, rho = rho))$p.value)

# P-vals from naively using fitted parameters
pvals_naive <- replicate(nrep, test_super_naive_gamma(genData(n, qgamma, shape = 3, scale = 1, copula = normalCopula, rho = rho))$p.value)

# Create a master data_frame with all the results
histogram <- c(rep("Copula", nrep), rep("Naive Parametric", nrep), rep("Super Naive", nrep))
p_values <- c(pvals_copula, pvals_parametric, pvals_naive)
results <- data_frame(p_values, histogram)

# Generate histograms plot
hist_copula_gamma <- ggplot(results) + 
                   geom_histogram(aes(x = p_values, fill = histogram), boundary = 0, binwidth = 1/20) + 
                   scale_x_continuous(name = "p-value", breaks=c(0, 1)) + 
                   theme(legend.position = "none") +
                   facet_wrap(~histogram, scales = "free_y")

print(proc.time() - ptm)

hist_copula_gamma
```

```{r}
# Testing bootstrap with copulas for GEV distribution
test_gev <- function(x, B = 100, wcopula = normalCopula) {
  
    n <- length(x)
    
    # Get observed stat
    fit <- fgev(x, std.err = FALSE)
    loc <- fit$estimate[1]
    scale <- fit$estimate[2]
    shape <- fit$estimate[3]
    
    stat  <- ks.test(x, 'pgev', loc = loc, scale = scale, shape = shape)$statistic
    
    # Get lag-1 sample auto-spearman rho
    rho  <-  cor(x[-1], x[-n], method = "spearman")
    r <- iRho(wcopula(), rho)
    wcop <- wcopula(r)
    
    # Parametric bootstrap to get an empirical distribution of stat
    stat.b <- double(n)

    for (i in 1:B) {
        # 1. The marginal distribution is the fitted dist
        # 2. There is temporal dependence
        u <- runif(n)
        for (j in 2:n) {
            u[j]  <- cCopula(c(u[j-1], u[j]), wcop, indices = 2, inverse = TRUE)
        }

        # Transform the bootstrap sample and fit the parameters
        x.b <- qgev(u, loc = loc, scale = scale, shape = shape)
        
        fit.b <- fgev(x.b, std.err = FALSE)
        loc.b <- fit.b$estimate[1]
        scale.b <- fit.b$estimate[2]
        shape.b <- fit.b$estimate[3]
        
        # Calculate bootstrap test statistic
        stat.b[i] <- ks.test(x.b, 'pgev', loc = loc.b, scale = scale.b, shape = shape.b)$statistic
    }
    
    # Return empirical p-value    
    p.value <- (sum(stat.b >= stat) + 0.5) / (B + 1)
    
    counter <<- counter + 1
    cat(counter, "")
    
    return(p.value)
}

# Parametric bootstrap to solve fitted parameters for GEV distribution
test_parametric_gev <- function(x, B = 1000) {
  
  # Summarize parameters
  fit <- fgev(x)
  loc <- fit$estimate[1]
  scale <- fit$estimate[2]
  shape <- fit$estimate[3]
  
  # Store KS statistic from using fitted parameters
  stat <- ks.test(x, "pgev", loc = loc, scale = scale, shape = shape)$statistic
  
  # Parametric bootstrap to approximate the null distribution
  n <- length(x)
  stat.b <- double(B)
  for (i in 1:B) {
    x.b <- rgev(n, loc = loc, scale = scale, shape = shape)
    
    fit.b <- fgev(x.b)
    loc.b <- fit.b$estimate[1]
    scale.b <- fit.b$estimate[2]
    shape.b <- fit.b$estimate[3]
    
    stat.b[i] <- ks.test(x.b, "pgev", shape = shape.b, scale = scale.b)$statistic
  }
  
  # Return empirical p-value
  p.value <- (sum(stat.b >= stat) + 0.5) / (B + 1)

  counter <<- counter + 1
  cat(counter, "")
  list(p.value = p.value)
}

# Naive function that incorrectly uses fitted parameters for GEV distribution
test_super_naive_gev <- function(x) {
  
  fit <- fgev(x)
  loc <- fit$estimate[1]
  scale <- fit$estimate[2]
  shape <- fit$estimate[3]
    
  p.value <- ks.test(x, "pgev", loc = loc, scale = scale, shape = shape)$p.value
  list(p.value = p.value)
}

ptm <- proc.time()

# Set variables
n <- 100
rho <- 0.5
counter <- 0
nrep <- 1000
B <- 100

# P-vals from using bootstrap with copulas
pvals_copula <- suppressWarnings(replicate(nrep, test_gev(genData(n, qgev, loc = 0, shape = 1, scale = 1, copula = normalCopula, rho = rho), B = B)))
counter <- 0

# P-vals from using parametric bootstrap
pvals_parametric <- suppressWarnings(replicate(nrep, test_parametric_gamma(genData(n, qgev, shape = 1, scale = 1, copula = normalCopula, rho = rho))$p.value))

# P-vals from naively using fitted parameters
pvals_naive <- suppressWarnings(replicate(nrep, test_super_naive_gamma(genData(n, qgev, shape = 1, scale = 1, copula = normalCopula, rho = rho))$p.value))

# Create a master data_frame with all the results
histogram <- c(rep("Copula", nrep), rep("Naive Parametric", nrep), rep("Super Naive", nrep))
p_values <- c(pvals_copula, pvals_parametric, pvals_naive)
results <- data_frame(p_values, histogram)

# Generate histograms plot
hist_copula_gev <- ggplot(results) + 
                   geom_histogram(aes(x = p_values, fill = histogram), boundary = 0, binwidth = 1/20) + 
                   scale_x_continuous(name = "p-value", breaks=c(0, 1)) + 
                   theme(legend.position = "none") +
                   facet_wrap(~histogram, scales = "free_y")

print(proc.time() - ptm)

hist_copula_gev

# Save the histogram figure
ggsave(filename = "hist_copula_gev.pdf", plot = hist_copula_gev, path = "../Manuscript", height = 2.1, width = 6)
```
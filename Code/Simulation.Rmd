---
title: "R Notebook"
output: html_notebook
---

```{r}
# Load packages
library(xtable)
library(dgof)
library(tidyverse)
library(KSgeneral)
library(snpar)
```

```{r hist_parametric}
# Test parametric bootstrap as a solution to fitting parameters
test_parametric <- function(x, B = 1000) {
  
  # Summarize parameters
  mu <- mean(x)
  sigma <- sd(x)
  
  # Store KS statistic from using fitted parameters
  stat <- ks.test(x, "pnorm", mu, sigma)$statistic
  
  # Parametric bootstrap to approximate the null distribution
  n <- length(x)
  stat.b <- double(B)
  for (i in 1:B) {
    x.b <- rnorm(n, mu, sigma)
    mu.b <- mean(x.b)
    sigma.b <- sd(x.b)
    stat.b[i] <- ks.test(x.b, "pnorm", mu.b, sigma.b)$statistic
    # write own ks test statistic formula here
    # is.character(y)
  }
  p.value <- (sum(stat.b >= stat) + 0.5) / (B + 1)
  
  list(p.value = p.value)
}

# Naive KS-test to show consequence of fitted parameters
test_naive <- function(x) {
  p.value <- ks.test(x, "pnorm", mean = mean(x), sd = sd(x))$p.value
  list(p.value = p.value)
}

# Generate results
pvals_parametric <- replicate(100, test_parametric(rnorm(100), B = 1000)$p.value)
pvals_naive <- replicate(100, test_naive(rnorm(100))$p.value)

# Create a master data_frame with all the results
histogram <- c(rep("Parametric", 100), rep("Naive", 100))
p_values <- c(pvals_parametric, pvals_naive)
results <- data_frame(p_values, histogram)

# Generate histograms plot
hist_parametric <- ggplot(results) + 
                   geom_histogram(aes(x = p_values, fill = histogram), boundary = 0, binwidth = 1/20) + 
                   scale_x_continuous(name = "p-value", breaks=c(0, 1)) + 
                   theme(legend.position = "none") +
                   facet_wrap(~histogram, scales = "free_y")

# Save the histogram figure
ggsave(filename = "hist_parametric.pdf", plot = hist_parametric, path = "../Manuscript", height = 2.1, width = 6)
```

```{r block functions}
# Functions supporting block bootstrap

# Add small noise to data
add_noise <- function(x) {
  
  # Grab variance and length
  v <- var(x)
  n <- length(x)
  
  # Generate noise where standard deviation is 1% of variance
  noise <- rnorm(n, mean = 0, sd = 1/100*v)
  
  # Return jittered data
  return(x + noise)
}

# Non-moving block generation
nmblk <- function(n, l) {

  # Number of blocks
  b <- n / l
  
  # Create non-moving block indices
  idx <- sample(seq(1, n - l + 1, by = l), b, replace = TRUE)
  
  # Return indices
  c(outer(0:(l - 1), idx, "+"))
}

# Moving block generation
mvblk <- function(n, l) {
    
  # Number of blocks
  b <- n / l
  
  # Create moving block indices
  idx <- sample(1:(n - l + 1), b, replace = TRUE)
  
  # Return indices
  c(outer(0:(l - 1), idx, "+"))
}
```

```{r hist_block}
# Block bootstrap function
blkboot <- function(tseries, statistic, R, l) {
  
  n <- length(tseries)
  
  # Gather observed statistic
  stat <- statistic(tseries)
  
  # Replicate block bootstrap samples with noise
  nm.stat <- replicate(R, statistic(add_noise(tseries[nmblk(n, l)])))
  mv.stat <- replicate(R, statistic(add_noise(tseries[mvblk(n, l)])))
  
  # Calculate p-values
  nmp.value <- (sum(nm.stat >= stat) + 0.5) / (R + 1)
  mvp.value <- (sum(mv.stat >= stat) + 0.5) / (R + 1)
  
  list(stat = stat, nmp.value = nmp.value, mvp.value = mvp.value)
}

# Calculate ks-statistic
ks_statistic <- function(x) ks.test(x, "pnorm")$statistic

# 1 test
do1rep <- function(n, ar, l) {
  
  # Create correlated data
  x <- arima.sim(list(ar = ar), rand.gen = rnorm, sd = sqrt(1-ar^2), n)
  
  # Apply block bootstrap
  bt <- blkboot(x, ks_statistic, R = 1000, l)
  
  list(stat = bt$stat, nmp.value = bt$nmp.value, mvp.value = bt$mvp.value)
}

# Naive example
test_naive_block <- function(ar, n) {
  
  # Generate correlated data
  x <- arima.sim(list(ar = ar), rand.gen = rnorm, sd = sqrt(1-ar^2), n)
  
  # Gather p-value
  p.value <- ks.test(x, "pnorm")$p.value
  
  list(p.value = p.value)
}

ptm <- proc.time()

n <- 100
ar <- 0.5
l = 5
n_tests <- 100

# Generate results
pvals_block <- replicate(n_tests, do1rep(n, ar, l)$mvp.value)
pvals_naive_block <- replicate(n_tests, test_naive_block(ar = ar, n = n)$p.value)

# Create a master data_frame with all the results
histogram <- c(rep("Block", n_tests), rep("Naive", n_tests))
p_values <- c(pvals_block, pvals_naive_block)
results <- data_frame(p_values, histogram)

# Generate histograms plot
hist_block <- ggplot(results) +
             geom_histogram(aes(x = p_values, fill = histogram), boundary = 0, binwidth = 1/20) + 
             scale_x_continuous(name = "p-value", breaks=c(0, 1)) + 
             facet_grid(~histogram) +
             theme(legend.position = "none")

# Save the histogram figure
ggsave(filename = "hist_block.pdf", plot = hist_block, path = "../Manuscript", height = 2.1, width = 6)

proc.time() - ptm
```

```{r}
test_snpar <- function(ar, n) {
  
  # Generate correlated data
  x <- arima.sim(list(ar = ar), rand.gen = rnorm, sd = sqrt(1-ar^2), n)
  
  # Gather p-value
  p.value <- snpar::KS.test(x, "pnorm")$p.value
  
  list(p.value = p.value)
}

n <- 100
ar <- 0.5
n_tests <- 1000

# Generate results
pvals_snpar <- replicate(n_tests, test_snpar(ar = ar, n = n)$p.value)
pvals_naive_block <- replicate(n_tests, test_naive_block(ar = ar, n = n)$p.value)

# Create a master data_frame with all the results
histogram <- c(rep("snpar", n_tests), rep("Naive", n_tests))
p_values <- c(pvals_snpar, pvals_naive_block)
results <- data_frame(p_values, histogram)

# Generate histograms plot
hist_snpar <- ggplot(results) +
             geom_histogram(aes(x = p_values, fill = histogram), boundary = 0, binwidth = 1/20) + 
             scale_x_continuous(name = "p-value", breaks=c(0, 1)) + 
             facet_grid(~histogram) + 
             theme(legend.position = "none")

hist_snpar
```

```{r hist_rounded}
# Test to show that rounding changes the power of the test
test_rounded <- function(n_tests, n_samples, digits) {
  
  p_values <- double(n_tests)
  
  for(i in 1:n_tests) {
    
    # Generate random rounded data, perform a KS-test, and store the p-value
    data <- round(rnorm(n_samples), digits)
    p_values[i] <- ks.test(data, "pnorm")$p.value
  }
  
  return(p_values)
}

# Create the histograms displaying p-values from each test
hist1 <- suppressWarnings(test_rounded(1000, 100, 2))
hist2 <- suppressWarnings(test_rounded(1000, 100, 1))

# Create a master data_frame with all the results
histogram <- c(rep(".01", 1000), rep(".1", 1000))
p_values <- c(hist1, hist2)
results <- data_frame(p_values, histogram)

# Generate histograms plot
hist_rounded <- ggplot(results) + 
                geom_histogram(aes(x = p_values, fill = histogram), binwidth = 1/20, boundary = 0) + 
                facet_grid(~histogram) +
                theme(legend.position = "none") +
                scale_x_continuous(name = "p-value", breaks = seq(0, 1))

# Save the histogram figure
ggsave(filename = "hist_rounded.pdf", plot = hist_rounded, path = "../Manuscript", height = 2.1, width = 6)
```

```{r hist_general}
# Test the KSgeneral package as a solution to rounded data
test_general <- function(n_tests, n_samples, digits, B = 100) {

  results1 <- double(n_tests)
  results2 <- double(n_tests)
  results3 <- double(n_tests)
  results4 <- double(n_tests)

  # Create the rounded normal step function
  left <- -4-0.1^digits
  y <- pnorm(seq(left, 4, by = 0.1^digits))
  sfun  <- stepfun(seq(-4, 4, by = 0.1^digits), y)
  
  for (i in 1:n_tests) {
    
    # Generate random rounded data, perform 3 KS-tests, and store the p-values
    # 1. Using the rounded normal step function
    # 2. Using the naive continuous standard normal function
    data <- round(rnorm(n_samples), digits)
    results1[i] <- KSgeneral::disc_ks_test(data, sfun, exact = TRUE)$p.value
    results2[i] <- dgof::ks.test(data, sfun)$p.value
    results3[i] <- ks.test(data, sfun, simulate.p.value = TRUE, B = B)$p.value
    results4[i] <- ks.test(data, "pnorm")$p.value
    
  }
  
  # Create a master data_frame for p-values
  test <- c(rep("KSgeneral", n_tests), rep("dgof", n_tests), rep("dgofsim", n_tests), rep("Naive", n_tests))
  digits <- c(rep(.1^digits, 4*n_tests))
  p_values <- c(results1, results2, results3, results4)
  results <- data_frame(p_values, test, digits)
  
  return(results)
}

ptm <- proc.time()

n_tests = 1000
n = 50

# Create the histograms displaying p-values from each test
test1 <- suppressWarnings(test_general(n_tests, n, 2))
test2 <- suppressWarnings(test_general(n_tests, n, 1))
results <- rbind(test1, test2)

# Generate histograms plot
hist_general <- ggplot(results) + 
                geom_histogram(aes(x = p_values, fill = test), boundary = 0, binwidth = 1/20) + 
                scale_x_continuous(name = "p-value", breaks=c(0, 1)) + 
                facet_grid(test~digits) +
                theme(legend.position = "none")

# Save the histogram figure
ggsave(filename = "hist_general.pdf", plot = hist_general, path = "../Manuscript", height = 4.2, width = 6)

proc.time() - ptm
# could try qqplot for unit interval
# is qqplot close to 45 degree line, otherwise no
```

```{r hist_correlationn}
# Test to show that autocorrelation changes the power of the test
test_correlation <- function(n_tests, ars) {
  
  # Create a master data_frame for p-values
  columns <- c("p_value", "ar")
  ar_results <- data.frame(matrix(ncol = 2, nrow = 0))
  colnames(ar_results) <- columns
  
  # For AR coefficients from -0.5 to 0.5
  for(i in 1:length(ars)) {
    
    for(j in 1:n_tests) {
      
      # Generate random correlated data, perform a KS-test, and store the p-value
      data <- arima.sim(model = list(ar = ars[i]), rand.gen = rnorm, sd = sqrt(1-ars[i]^2), n = 100)
      ar_results <- add_row(ar_results, p_value = ks.test(data, "pnorm")$p.value, ar = round(ars[i], 1))
    }
  }
  
  return(ar_results)
}

 # Set AR coefficients and generate results
ars <- seq(-0.3, 0.3, by = 0.1)
ar_results <- test_correlation(1000, ars)

# Generate histograms plot
hist_correlation <- ggplot(ar_results) + 
                    geom_histogram(aes(x = p_value, fill = ar), boundary = 0, binwidth = 1/20) + 
                    facet_grid(~ar) +
                    theme(legend.position = "none") +
                    scale_x_continuous(name = "p-value", breaks=c(0, 1))

# Save the histogram figure
ggsave(filename = "hist_correlation.pdf", plot = hist_correlation, path = "../Manuscript", height = 2.1, width = 6)
```